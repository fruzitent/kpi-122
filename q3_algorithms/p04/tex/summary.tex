\section{Висновки}
\label{sec:summary}

\begin{enumerate}
    \item Яким чином організовані багатовимірні масиви в C/C++?
          \begin{itemize}
              \item Статичний
                    \begin{minted}{cpp}
                        int array[n][m];
                    \end{minted}
              \item Динамічний
                    \begin{minted}{cpp}
                        int** array = new int*[n];
                        for(auto i = 0; i < n; ++i) {
                            array[i] = new int[m] {};
                        }
                    \end{minted}
          \end{itemize}
    \item Як розташовуються елементи у багатовимірних масивах різних типів в C/C++? \\
          У статичному масиві всі елементи розташовуються підряд.
          Динамічний масив можна створити як, щоб елементи розташовувались підряд,
          так і щоб елементи розташовувались хаотично.
    \item Скільки необхідно циклів для перебору елементів двовимірного масиву? Наведіть приклади.
          \begin{minted}{cpp}
                for(auto i = 0; i < n; ++i) {
                    for (auto j = 0; j < m; ++j) {
                        array[i][j] = 0;
                    }
                }

                for (auto i =0; i < n * m; ++i) {
                    array[i / m][i % m] = 0;
                }
          \end{minted}
    \item Чи можна створити динамічний двовимірний масив, не створюючи кожен його рядок окремо? \\
          Треба створити список з покажчиків, та список з елементів.
    \item Яка умова визначення елементів на головній та другорядній діагоналі двовимірного масиву? \\
          \begin{itemize}
              \item Головна діагональ: $[i][i]$
              \item Другорядна діагональ: $[i][n - 1 - i]$
          \end{itemize}
    \item Приведіть код звернення до елементів k-го стовпчика та k-го рядка двовимірного масиву. \\
          \begin{minted}{cpp}
                    for(auto i = 0; i < n; ++i) {
                        std::cout << array[i][k] << "\n";
                    }

                    for(auto j = 0; j < m; ++i) {
                        std::cout << array[k][j] << "\n";
                    }
            \end{minted}
    \item На скільки байт та чому змінюють значення покажчика операції інкремента/декремента? \\
          Значення показчика змінюється на $зсув * розмір типу$ байт
    \item Як можна під час виконання програми змінити розмір масиву? \\
          \begin{enumerate}
              \item Створити новий масив
              \item Перенести дані зі старого масиву в новий
              \item Видалити старий масив
          \end{enumerate}
    \item Які операції можливі над масивом, як над набором елементів? \\
          \begin{itemize}
              \item Векторні операції
              \item Фільтрування
              \item Сортування
          \end{itemize}
    \item В чому сильні та слабкі сторони використання масивів? \\
          Зміна структури списку не вимагає великих затрат часу та пам'яті,
          проте хаотичне звернення є дуже затратним.
\end{enumerate}

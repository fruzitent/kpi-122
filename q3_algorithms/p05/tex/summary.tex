\section{Висновки}
\label{sec:summary}

\begin{enumerate}
      \item Як задаються рядки в C/C++? Які є альтернативи C-рядку та в чому їх переваги та недоліки?
            \begin{itemize}
                  \item масив символів з заданим розміром на стеку, проте його може не вистачити.
                  \item покажчик на статичну пам'ять невідомого розміру,
                        що потрібно вручну звільняти,
                        а кінець рядка визначається нульовим термінатором.
            \end{itemize}
            Альтернативною С-рядку є використання класу std::string
            зі стандартної бібліотеки STL,
            що відповідає принципу Resource Acquisition is initialization
      \item В якому вигляді символи зберігаються в пам'яті? \\
            Як числові коди таблиці символів
      \item Чим відрізняється ініціалізація символу та рядка? Запишіть різні способи ініціалізації рядка. \\
            Символ оголошується в одинарних лапках, виділяється 1 байт пам'яті.
            Рядок оголошується в подвійних лапках, що є масивом символів та закінчується нульовим термінатором.
      \item Які є способи запису символу у рядку? Які символи можна записати яким з цих способів?
            \begin{itemize}
                  \item друковані - "a"
                  \item керуючі - "\textbackslash t"
                  \item 8-бітові - "\textbackslash 012"
                  \item 16-бітові - "\textbackslash u0123"
            \end{itemize}
      \item Як слід записати текст, частина якого має виводитись з нового рядка? \\
            Додати спец-символ "\textbackslash n" в місці переносу рядка.
      \item Як розмістяться в пам'яті кілька строкових літералів, які в коді записані один за одним? \\
            Символи будут записані в пам'яті один за одним,
            а в кінці буде доданий нульовий термінатор.
      \item Чи може нульовий символ бути в середині рядка? До чого це приведе? \\
            Частина рядка після нульового символу буде проігнорована.
      \item Якою функцією можна зчитати з клавіатури рядок, що містить пробіли?
            \mint{cpp}|char* std::fgets(char* str, int count, std::FILE* stream);|
      \item Опишіть, що роблять та що повертають функції strlen(), str(n)cmp(i)(), strstr(), str(r)chr().
            \begin{itemize}
                  \item \mint{cpp}|std::size_t std::strlen(const char* str);|
                        Повертає кількість символів у символьному масиві,
                        на перший елемент якого вказує str,
                        до першого нульового символу включно.
                  \item \mint{cpp}|int std::strcmp(const char* lhs, const char* rhs);|
                        Порівнює два рядки з нульовим закінченням лексикографічно.
                        Результатом є різниця між значеннями першої пари символів.
                  \item \mint{cpp}|int std::strncmp(const char* lhs, const char* rhs, std::size_t count);|
                        Порівнює два рядки з нульовим закінченням лексикографічно.
                        Символи, що йдуть після нульового символу, не порівнюються.
                        Результатом є різниця між значеннями першої пари символів.
                  \item \mint{cpp}|const char* std::strstr(const char* haystack, const char* needle);|
                        Знаходить перше входження needle у рядку haystack
                        Кінцеві нульові символи не порівнюються.
                  \item \mint{cpp}|const char* std::strchr(const char* str, int ch);|
                        Знаходить перше входження символу ch у рядку str
            \end{itemize}
      \item В чому різниця між функціями str(n)cpy() та str(n)cat()?
            \begin{itemize}
                  \item \mint{cpp}|char* std::strcpy(char* dest, const char* src);|
                        Копіює рядок src, включно з нульовим термінатором, до рядка dest.
                  \item \mint{cpp}|char* std::strcat(char* dest, const char* src);|
                        Додає копію рядка src, у кінець рядка dest.
                        Символ src[0] замінює нульовий термінатор в кінці dest.
                        Результуючий байтовий рядок є нуль-термінатором.
                  \item \mint{cpp}|char* std::strncpy(char* dest, const char* src, std::size_t count);|
                        Копіює не більше count символів рядка src
                        (включаючи завершальний нульовий символ), до рядка dest.
                        Якщо значення count досягнуто до того, як було скопійовано весь рядок src,
                        результуючий масив символів не буде завершуватися нулем.
                        Якщо після копіювання завершального нульового символу з src значення count
                        не досягнуто, до dest записуються додаткові нульові символи,
                        доки не буде досягнуто значення count символів.
                  \item \mint{cpp}|char* std::strncat(char* dest, const char* src, std::size_t count);|
                        Додає рядок src, до рядка dest. Копіюється не більше лічильника символів.
                        Результуючий рядок завершується нульовим символом.
            \end{itemize}
\end{enumerate}
